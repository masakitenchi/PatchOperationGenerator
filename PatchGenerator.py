from io import TextIOWrapper
from typing import Any
import lxml.etree as ET


# A valid PatchOperation consists of a xpath, a value and a patchclass.
"""
<Operation Class="PatchOperationAdd">
	<xpath>...</xpath>
	<value>...</value>
</Operation>
"""

class PatchOperation:
	@staticmethod
	def GeneratePatchOperation(*, patchclass: str, xpath: str, value: str | ET._Element = None, attribute: str = None) -> ET._Element:
		node_name = xpath.split("/")[-1]
		operation = ET.Element("Operation", attrib={"Class": patchclass})
		operation.append(ET.fromstring(f"<xpath>{xpath}</xpath>"))
		#print(f'class : {patchclass}, xpath : {xpath}, value : {value}, attribute : {attribute}')
		if patchclass == 'PatchOperationRemove':
			# Remove only needs xpath
			pass
		elif isinstance(value, ET._Element):
			value_node = ET.Element("value")
			value_node.append(value)
			operation.append(value_node)
		elif patchclass == "PatchOperationAttributeSet":
			if value != "None":
				operation.append(ET.fromstring(f"<attribute>{attribute}</attribute>"))
				operation.append(ET.fromstring(f"<value>{value}</value>"))
			else:
				operation.attrib["Class"] = "PatchOperationAttributeRemove"
				operation.append(ET.fromstring(f"<attribute>{attribute}</attribute>"))
		else:
			operation.append(ET.fromstring(f"<value><{node_name}>{value}</{node_name}></value>"))

		return operation

	def MergePatchOperation(patchoperations: list[ET.Element]) -> list[ET._Element]:
		#dict[(patchclass, xpath), value]
		operationdict: dict[tuple(str, str), str] = {}
		for item in patchoperations:
			patchclass = item.get("Class")
			xpath = item.find("xpath").text
			value = "".join(item.find("value").itertext())
			if (patchclass, xpath) in operationdict.keys():
				if patchclass == "PatchOperationAdd":
					operationdict[(patchclass, xpath)] = operationdict[(patchclass, xpath)] + '\n' + value
				elif patchclass == "PatchOperationReplace":
					operationdict[(patchclass, xpath)] = value
				elif patchclass == "PatchOperationRemove":
					operationdict[(patchclass, xpath)] = None
				elif patchclass == "PatchOperationAttributeSet":
					operationdict[(patchclass, xpath)] = value
		patchoperations = [PatchOperation.GeneratePatchOperation(patchclass=item[0], xpath=item[1], value=operationdict[item]) for item in operationdict]
		return patchoperations
	
	def write_all_operations(filepath: str | TextIOWrapper, patchoperations: list[ET._Element]) -> None:
		# write all operations to a file
		root = ET.Element("Patch")
		comment = ET.Comment("Generated by PatchGenerator.py")
		root.addprevious(comment)
		for item in patchoperations:
			root.append(item)
		tree = ET.ElementTree(root)
		ET.indent(tree, space="\t")
		tree.write(filepath, pretty_print=True, xml_declaration=True, encoding="utf-8")